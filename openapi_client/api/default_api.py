# coding: utf-8

"""
    weather.gov API

    weather.gov API  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def alerts_active_area_area_get(self, area, **kwargs):  # noqa: E501
        """alerts_active_area_area_get  # noqa: E501

        Returns active alerts for the given area (state or marine area)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_area_area_get(area, async_req=True)
        >>> result = thread.get()

        :param area: (required)
        :type area: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_active_area_area_get_with_http_info(area, **kwargs)  # noqa: E501

    def alerts_active_area_area_get_with_http_info(self, area, **kwargs):  # noqa: E501
        """alerts_active_area_area_get  # noqa: E501

        Returns active alerts for the given area (state or marine area)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_area_area_get_with_http_info(area, async_req=True)
        >>> result = thread.get()

        :param area: (required)
        :type area: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'area'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_area_area_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'area' is set
        if self.api_client.client_side_validation and ('area' not in local_var_params or  # noqa: E501
                                                        local_var_params['area'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `area` when calling `alerts_active_area_area_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'area' in local_var_params:
            path_params['area'] = local_var_params['area']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/area/{area}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_active_count_get(self, **kwargs):  # noqa: E501
        """alerts_active_count_get  # noqa: E501

        Returns info on the number of active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_count_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_active_count_get_with_http_info(**kwargs)  # noqa: E501

    def alerts_active_count_get_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_active_count_get  # noqa: E501

        Returns info on the number of active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_count_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_count_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_active_get(self, **kwargs):  # noqa: E501
        """alerts_active_get  # noqa: E501

        Returns all currently active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_get(async_req=True)
        >>> result = thread.get()

        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param region_type: Region type (land or marine)  This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param point: Point (latitude,longitude)  This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code  This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[str]
        :param area: State/marine area code  This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[str]
        :param zone: Zone ID (forecast or county)  This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[str]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[str]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_active_get_with_http_info(**kwargs)  # noqa: E501

    def alerts_active_get_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_active_get  # noqa: E501

        Returns all currently active alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param region_type: Region type (land or marine)  This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param point: Point (latitude,longitude)  This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code  This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[str]
        :param area: State/marine area code  This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[str]
        :param zone: Zone ID (forecast or county)  This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[str]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[str]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'status',
            'message_type',
            'event',
            'code',
            'region_type',
            'point',
            'region',
            'area',
            'zone',
            'urgency',
            'severity',
            'certainty',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `alerts_active_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `alerts_active_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'message_type' in local_var_params and local_var_params['message_type'] is not None:  # noqa: E501
            query_params.append(('message_type', local_var_params['message_type']))  # noqa: E501
            collection_formats['message_type'] = 'csv'  # noqa: E501
        if 'event' in local_var_params and local_var_params['event'] is not None:  # noqa: E501
            query_params.append(('event', local_var_params['event']))  # noqa: E501
            collection_formats['event'] = 'csv'  # noqa: E501
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501
            collection_formats['code'] = 'csv'  # noqa: E501
        if 'region_type' in local_var_params and local_var_params['region_type'] is not None:  # noqa: E501
            query_params.append(('region_type', local_var_params['region_type']))  # noqa: E501
        if 'point' in local_var_params and local_var_params['point'] is not None:  # noqa: E501
            query_params.append(('point', local_var_params['point']))  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'area' in local_var_params and local_var_params['area'] is not None:  # noqa: E501
            query_params.append(('area', local_var_params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'zone' in local_var_params and local_var_params['zone'] is not None:  # noqa: E501
            query_params.append(('zone', local_var_params['zone']))  # noqa: E501
            collection_formats['zone'] = 'csv'  # noqa: E501
        if 'urgency' in local_var_params and local_var_params['urgency'] is not None:  # noqa: E501
            query_params.append(('urgency', local_var_params['urgency']))  # noqa: E501
            collection_formats['urgency'] = 'csv'  # noqa: E501
        if 'severity' in local_var_params and local_var_params['severity'] is not None:  # noqa: E501
            query_params.append(('severity', local_var_params['severity']))  # noqa: E501
            collection_formats['severity'] = 'csv'  # noqa: E501
        if 'certainty' in local_var_params and local_var_params['certainty'] is not None:  # noqa: E501
            query_params.append(('certainty', local_var_params['certainty']))  # noqa: E501
            collection_formats['certainty'] = 'csv'  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_active_region_region_get(self, region, **kwargs):  # noqa: E501
        """alerts_active_region_region_get  # noqa: E501

        Returns active alerts for the given marine region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_region_region_get(region, async_req=True)
        >>> result = thread.get()

        :param region: (required)
        :type region: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_active_region_region_get_with_http_info(region, **kwargs)  # noqa: E501

    def alerts_active_region_region_get_with_http_info(self, region, **kwargs):  # noqa: E501
        """alerts_active_region_region_get  # noqa: E501

        Returns active alerts for the given marine region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_region_region_get_with_http_info(region, async_req=True)
        >>> result = thread.get()

        :param region: (required)
        :type region: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'region'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_region_region_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'region' is set
        if self.api_client.client_side_validation and ('region' not in local_var_params or  # noqa: E501
                                                        local_var_params['region'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `region` when calling `alerts_active_region_region_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'region' in local_var_params:
            path_params['region'] = local_var_params['region']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/region/{region}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_active_zone_zone_id_get(self, zone_id, **kwargs):  # noqa: E501
        """alerts_active_zone_zone_id_get  # noqa: E501

        Returns active alerts for the given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_zone_zone_id_get(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_active_zone_zone_id_get_with_http_info(zone_id, **kwargs)  # noqa: E501

    def alerts_active_zone_zone_id_get_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """alerts_active_zone_zone_id_get  # noqa: E501

        Returns active alerts for the given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_active_zone_zone_id_get_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'zone_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_active_zone_zone_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'zone_id' is set
        if self.api_client.client_side_validation and ('zone_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['zone_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `zone_id` when calling `alerts_active_zone_zone_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in local_var_params:
            path_params['zoneId'] = local_var_params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/active/zone/{zoneId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_get(self, **kwargs):  # noqa: E501
        """alerts_get  # noqa: E501

        Returns all alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_get(async_req=True)
        >>> result = thread.get()

        :param active: Active alerts
        :type active: bool
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param region_type: Region type (land or marine)  This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param point: Point (latitude,longitude)  This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code  This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[str]
        :param area: State/marine area code  This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[str]
        :param zone: Zone ID (forecast or county)  This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[str]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[str]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[str]
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_get_with_http_info(**kwargs)  # noqa: E501

    def alerts_get_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_get  # noqa: E501

        Returns all alerts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param active: Active alerts
        :type active: bool
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param status: Status (actual, exercise, system, test, draft)
        :type status: list[str]
        :param message_type: Message type (alert, update, cancel)
        :type message_type: list[str]
        :param event: Event name
        :type event: list[str]
        :param code: Event code
        :type code: list[str]
        :param region_type: Region type (land or marine)  This parameter is incompatible with the following parameters: area, point, region, zone
        :type region_type: str
        :param point: Point (latitude,longitude)  This parameter is incompatible with the following parameters: area, region, region_type, zone
        :type point: str
        :param region: Marine region code  This parameter is incompatible with the following parameters: area, point, region_type, zone
        :type region: list[str]
        :param area: State/marine area code  This parameter is incompatible with the following parameters: point, region, region_type, zone
        :type area: list[str]
        :param zone: Zone ID (forecast or county)  This parameter is incompatible with the following parameters: area, point, region, region_type
        :type zone: list[str]
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :type urgency: list[str]
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :type severity: list[str]
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :type certainty: list[str]
        :param limit: Limit
        :type limit: int
        :param cursor: Pagination cursor
        :type cursor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'active',
            'start',
            'end',
            'status',
            'message_type',
            'event',
            'code',
            'region_type',
            'point',
            'region',
            'area',
            'zone',
            'urgency',
            'severity',
            'certainty',
            'limit',
            'cursor'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `alerts_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `alerts_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'active' in local_var_params and local_var_params['active'] is not None:  # noqa: E501
            query_params.append(('active', local_var_params['active']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
            collection_formats['status'] = 'csv'  # noqa: E501
        if 'message_type' in local_var_params and local_var_params['message_type'] is not None:  # noqa: E501
            query_params.append(('message_type', local_var_params['message_type']))  # noqa: E501
            collection_formats['message_type'] = 'csv'  # noqa: E501
        if 'event' in local_var_params and local_var_params['event'] is not None:  # noqa: E501
            query_params.append(('event', local_var_params['event']))  # noqa: E501
            collection_formats['event'] = 'csv'  # noqa: E501
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501
            collection_formats['code'] = 'csv'  # noqa: E501
        if 'region_type' in local_var_params and local_var_params['region_type'] is not None:  # noqa: E501
            query_params.append(('region_type', local_var_params['region_type']))  # noqa: E501
        if 'point' in local_var_params and local_var_params['point'] is not None:  # noqa: E501
            query_params.append(('point', local_var_params['point']))  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'area' in local_var_params and local_var_params['area'] is not None:  # noqa: E501
            query_params.append(('area', local_var_params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'zone' in local_var_params and local_var_params['zone'] is not None:  # noqa: E501
            query_params.append(('zone', local_var_params['zone']))  # noqa: E501
            collection_formats['zone'] = 'csv'  # noqa: E501
        if 'urgency' in local_var_params and local_var_params['urgency'] is not None:  # noqa: E501
            query_params.append(('urgency', local_var_params['urgency']))  # noqa: E501
            collection_formats['urgency'] = 'csv'  # noqa: E501
        if 'severity' in local_var_params and local_var_params['severity'] is not None:  # noqa: E501
            query_params.append(('severity', local_var_params['severity']))  # noqa: E501
            collection_formats['severity'] = 'csv'  # noqa: E501
        if 'certainty' in local_var_params and local_var_params['certainty'] is not None:  # noqa: E501
            query_params.append(('certainty', local_var_params['certainty']))  # noqa: E501
            collection_formats['certainty'] = 'csv'  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'cursor' in local_var_params and local_var_params['cursor'] is not None:  # noqa: E501
            query_params.append(('cursor', local_var_params['cursor']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/atom+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_id_get(self, id, **kwargs):  # noqa: E501
        """alerts_id_get  # noqa: E501

        Returns a specific alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_id_get_with_http_info(id, **kwargs)  # noqa: E501

    def alerts_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """alerts_id_get  # noqa: E501

        Returns a specific alert  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `alerts_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/cap+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def alerts_types_get(self, **kwargs):  # noqa: E501
        """alerts_types_get  # noqa: E501

        Returns a list of alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_types_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.alerts_types_get_with_http_info(**kwargs)  # noqa: E501

    def alerts_types_get_with_http_info(self, **kwargs):  # noqa: E501
        """alerts_types_get  # noqa: E501

        Returns a list of alert types  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.alerts_types_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method alerts_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/alerts/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def glossary_get(self, **kwargs):  # noqa: E501
        """glossary_get  # noqa: E501

        Returns glossary terms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.glossary_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.glossary_get_with_http_info(**kwargs)  # noqa: E501

    def glossary_get_with_http_info(self, **kwargs):  # noqa: E501
        """glossary_get  # noqa: E501

        Returns glossary terms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.glossary_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method glossary_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/glossary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def gridpoints_wfo_xy_forecast_get(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_forecast_get  # noqa: E501

        Returns a textual forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_forecast_get(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):  * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.gridpoints_wfo_xy_forecast_get_with_http_info(wfo, x, y, **kwargs)  # noqa: E501

    def gridpoints_wfo_xy_forecast_get_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_forecast_get  # noqa: E501

        Returns a textual forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_forecast_get_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):  * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'wfo',
            'x',
            'y',
            'feature_flags',
            'units'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoints_wfo_xy_forecast_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'wfo' is set
        if self.api_client.client_side_validation and ('wfo' not in local_var_params or  # noqa: E501
                                                        local_var_params['wfo'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wfo` when calling `gridpoints_wfo_xy_forecast_get`")  # noqa: E501
        # verify the required parameter 'x' is set
        if self.api_client.client_side_validation and ('x' not in local_var_params or  # noqa: E501
                                                        local_var_params['x'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `x` when calling `gridpoints_wfo_xy_forecast_get`")  # noqa: E501
        # verify the required parameter 'y' is set
        if self.api_client.client_side_validation and ('y' not in local_var_params or  # noqa: E501
                                                        local_var_params['y'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `y` when calling `gridpoints_wfo_xy_forecast_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'x' in local_var_params and local_var_params['x'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x` when calling `gridpoints_wfo_xy_forecast_get`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'y' in local_var_params and local_var_params['y'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `y` when calling `gridpoints_wfo_xy_forecast_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'wfo' in local_var_params:
            path_params['wfo'] = local_var_params['wfo']  # noqa: E501
        if 'x' in local_var_params:
            path_params['x'] = local_var_params['x']  # noqa: E501
        if 'y' in local_var_params:
            path_params['y'] = local_var_params['y']  # noqa: E501

        query_params = []
        if 'units' in local_var_params and local_var_params['units'] is not None:  # noqa: E501
            query_params.append(('units', local_var_params['units']))  # noqa: E501

        header_params = {}
        if 'feature_flags' in local_var_params:
            header_params['Feature-Flags'] = local_var_params['feature_flags']  # noqa: E501
            collection_formats['Feature-Flags'] = 'csv'  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def gridpoints_wfo_xy_forecast_hourly_get(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_forecast_hourly_get  # noqa: E501

        Returns a textual hourly forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_forecast_hourly_get(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):  * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.gridpoints_wfo_xy_forecast_hourly_get_with_http_info(wfo, x, y, **kwargs)  # noqa: E501

    def gridpoints_wfo_xy_forecast_hourly_get_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_forecast_hourly_get  # noqa: E501

        Returns a textual hourly forecast for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_forecast_hourly_get_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param feature_flags: Enable future and experimental features (see documentation for more info):  * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :type feature_flags: list[str]
        :param units: Use US customary or SI (metric) units in textual output
        :type units: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'wfo',
            'x',
            'y',
            'feature_flags',
            'units'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoints_wfo_xy_forecast_hourly_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'wfo' is set
        if self.api_client.client_side_validation and ('wfo' not in local_var_params or  # noqa: E501
                                                        local_var_params['wfo'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wfo` when calling `gridpoints_wfo_xy_forecast_hourly_get`")  # noqa: E501
        # verify the required parameter 'x' is set
        if self.api_client.client_side_validation and ('x' not in local_var_params or  # noqa: E501
                                                        local_var_params['x'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `x` when calling `gridpoints_wfo_xy_forecast_hourly_get`")  # noqa: E501
        # verify the required parameter 'y' is set
        if self.api_client.client_side_validation and ('y' not in local_var_params or  # noqa: E501
                                                        local_var_params['y'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `y` when calling `gridpoints_wfo_xy_forecast_hourly_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'x' in local_var_params and local_var_params['x'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x` when calling `gridpoints_wfo_xy_forecast_hourly_get`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'y' in local_var_params and local_var_params['y'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `y` when calling `gridpoints_wfo_xy_forecast_hourly_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'wfo' in local_var_params:
            path_params['wfo'] = local_var_params['wfo']  # noqa: E501
        if 'x' in local_var_params:
            path_params['x'] = local_var_params['x']  # noqa: E501
        if 'y' in local_var_params:
            path_params['y'] = local_var_params['y']  # noqa: E501

        query_params = []
        if 'units' in local_var_params and local_var_params['units'] is not None:  # noqa: E501
            query_params.append(('units', local_var_params['units']))  # noqa: E501

        header_params = {}
        if 'feature_flags' in local_var_params:
            header_params['Feature-Flags'] = local_var_params['feature_flags']  # noqa: E501
            collection_formats['Feature-Flags'] = 'csv'  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/forecast/hourly', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def gridpoints_wfo_xy_get(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_get  # noqa: E501

        Returns raw numerical forecast data for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_get(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.gridpoints_wfo_xy_get_with_http_info(wfo, x, y, **kwargs)  # noqa: E501

    def gridpoints_wfo_xy_get_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_get  # noqa: E501

        Returns raw numerical forecast data for a 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_get_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'wfo',
            'x',
            'y'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoints_wfo_xy_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'wfo' is set
        if self.api_client.client_side_validation and ('wfo' not in local_var_params or  # noqa: E501
                                                        local_var_params['wfo'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wfo` when calling `gridpoints_wfo_xy_get`")  # noqa: E501
        # verify the required parameter 'x' is set
        if self.api_client.client_side_validation and ('x' not in local_var_params or  # noqa: E501
                                                        local_var_params['x'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `x` when calling `gridpoints_wfo_xy_get`")  # noqa: E501
        # verify the required parameter 'y' is set
        if self.api_client.client_side_validation and ('y' not in local_var_params or  # noqa: E501
                                                        local_var_params['y'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `y` when calling `gridpoints_wfo_xy_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'x' in local_var_params and local_var_params['x'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x` when calling `gridpoints_wfo_xy_get`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'y' in local_var_params and local_var_params['y'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `y` when calling `gridpoints_wfo_xy_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'wfo' in local_var_params:
            path_params['wfo'] = local_var_params['wfo']  # noqa: E501
        if 'x' in local_var_params:
            path_params['x'] = local_var_params['x']  # noqa: E501
        if 'y' in local_var_params:
            path_params['y'] = local_var_params['y']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def gridpoints_wfo_xy_stations_get(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_stations_get  # noqa: E501

        Returns a list of observation stations usable for a given 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_stations_get(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.gridpoints_wfo_xy_stations_get_with_http_info(wfo, x, y, **kwargs)  # noqa: E501

    def gridpoints_wfo_xy_stations_get_with_http_info(self, wfo, x, y, **kwargs):  # noqa: E501
        """gridpoints_wfo_xy_stations_get  # noqa: E501

        Returns a list of observation stations usable for a given 2.5km grid area  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.gridpoints_wfo_xy_stations_get_with_http_info(wfo, x, y, async_req=True)
        >>> result = thread.get()

        :param wfo: (required)
        :type wfo: str
        :param x: (required)
        :type x: int
        :param y: (required)
        :type y: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'wfo',
            'x',
            'y'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gridpoints_wfo_xy_stations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'wfo' is set
        if self.api_client.client_side_validation and ('wfo' not in local_var_params or  # noqa: E501
                                                        local_var_params['wfo'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `wfo` when calling `gridpoints_wfo_xy_stations_get`")  # noqa: E501
        # verify the required parameter 'x' is set
        if self.api_client.client_side_validation and ('x' not in local_var_params or  # noqa: E501
                                                        local_var_params['x'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `x` when calling `gridpoints_wfo_xy_stations_get`")  # noqa: E501
        # verify the required parameter 'y' is set
        if self.api_client.client_side_validation and ('y' not in local_var_params or  # noqa: E501
                                                        local_var_params['y'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `y` when calling `gridpoints_wfo_xy_stations_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'x' in local_var_params and local_var_params['x'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `x` when calling `gridpoints_wfo_xy_stations_get`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'y' in local_var_params and local_var_params['y'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `y` when calling `gridpoints_wfo_xy_stations_get`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'wfo' in local_var_params:
            path_params['wfo'] = local_var_params['wfo']  # noqa: E501
        if 'x' in local_var_params:
            path_params['x'] = local_var_params['x']  # noqa: E501
        if 'y' in local_var_params:
            path_params['y'] = local_var_params['y']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/gridpoints/{wfo}/{x},{y}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def icons_get(self, **kwargs):  # noqa: E501
        """icons_get  # noqa: E501

        Returns a list of icon codes and textual descriptions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.icons_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.icons_get_with_http_info(**kwargs)  # noqa: E501

    def icons_get_with_http_info(self, **kwargs):  # noqa: E501
        """icons_get  # noqa: E501

        Returns a list of icon codes and textual descriptions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.icons_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method icons_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/icons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def icons_set_time_of_day_first_second_get(self, set, time_of_day, first, second, **kwargs):  # noqa: E501
        """icons_set_time_of_day_first_second_get  # noqa: E501

        Returns a forecast icon  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.icons_set_time_of_day_first_second_get(set, time_of_day, first, second, async_req=True)
        >>> result = thread.get()

        :param set: (required)
        :type set: str
        :param time_of_day: (required)
        :type time_of_day: str
        :param first: (required)
        :type first: str
        :param second: (required)
        :type second: str
        :param size: Font size
        :type size: AnyOfstringinteger
        :param fontsize: Font size
        :type fontsize: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.icons_set_time_of_day_first_second_get_with_http_info(set, time_of_day, first, second, **kwargs)  # noqa: E501

    def icons_set_time_of_day_first_second_get_with_http_info(self, set, time_of_day, first, second, **kwargs):  # noqa: E501
        """icons_set_time_of_day_first_second_get  # noqa: E501

        Returns a forecast icon  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.icons_set_time_of_day_first_second_get_with_http_info(set, time_of_day, first, second, async_req=True)
        >>> result = thread.get()

        :param set: (required)
        :type set: str
        :param time_of_day: (required)
        :type time_of_day: str
        :param first: (required)
        :type first: str
        :param second: (required)
        :type second: str
        :param size: Font size
        :type size: AnyOfstringinteger
        :param fontsize: Font size
        :type fontsize: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'set',
            'time_of_day',
            'first',
            'second',
            'size',
            'fontsize'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method icons_set_time_of_day_first_second_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'set' is set
        if self.api_client.client_side_validation and ('set' not in local_var_params or  # noqa: E501
                                                        local_var_params['set'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `set` when calling `icons_set_time_of_day_first_second_get`")  # noqa: E501
        # verify the required parameter 'time_of_day' is set
        if self.api_client.client_side_validation and ('time_of_day' not in local_var_params or  # noqa: E501
                                                        local_var_params['time_of_day'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `time_of_day` when calling `icons_set_time_of_day_first_second_get`")  # noqa: E501
        # verify the required parameter 'first' is set
        if self.api_client.client_side_validation and ('first' not in local_var_params or  # noqa: E501
                                                        local_var_params['first'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `first` when calling `icons_set_time_of_day_first_second_get`")  # noqa: E501
        # verify the required parameter 'second' is set
        if self.api_client.client_side_validation and ('second' not in local_var_params or  # noqa: E501
                                                        local_var_params['second'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `second` when calling `icons_set_time_of_day_first_second_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'fontsize' in local_var_params and local_var_params['fontsize'] > 24:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `fontsize` when calling `icons_set_time_of_day_first_second_get`, must be a value less than or equal to `24`")  # noqa: E501
        if self.api_client.client_side_validation and 'fontsize' in local_var_params and local_var_params['fontsize'] < 2:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `fontsize` when calling `icons_set_time_of_day_first_second_get`, must be a value greater than or equal to `2`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'set' in local_var_params:
            path_params['set'] = local_var_params['set']  # noqa: E501
        if 'time_of_day' in local_var_params:
            path_params['timeOfDay'] = local_var_params['time_of_day']  # noqa: E501
        if 'first' in local_var_params:
            path_params['first'] = local_var_params['first']  # noqa: E501
        if 'second' in local_var_params:
            path_params['second'] = local_var_params['second']  # noqa: E501

        query_params = []
        if 'size' in local_var_params and local_var_params['size'] is not None:  # noqa: E501
            query_params.append(('size', local_var_params['size']))  # noqa: E501
        if 'fontsize' in local_var_params and local_var_params['fontsize'] is not None:  # noqa: E501
            query_params.append(('fontsize', local_var_params['fontsize']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/icons/{set}/{timeOfDay}/{first}/{second}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def offices_office_id_get(self, office_id, **kwargs):  # noqa: E501
        """offices_office_id_get  # noqa: E501

        Returns metadata about a NWS forecast office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_get(office_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.offices_office_id_get_with_http_info(office_id, **kwargs)  # noqa: E501

    def offices_office_id_get_with_http_info(self, office_id, **kwargs):  # noqa: E501
        """offices_office_id_get  # noqa: E501

        Returns metadata about a NWS forecast office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_get_with_http_info(office_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'office_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method offices_office_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'office_id' is set
        if self.api_client.client_side_validation and ('office_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['office_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `office_id` when calling `offices_office_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in local_var_params:
            path_params['officeId'] = local_var_params['office_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def offices_office_id_headlines_get(self, office_id, **kwargs):  # noqa: E501
        """offices_office_id_headlines_get  # noqa: E501

        Returns a list of news headlines for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_headlines_get(office_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.offices_office_id_headlines_get_with_http_info(office_id, **kwargs)  # noqa: E501

    def offices_office_id_headlines_get_with_http_info(self, office_id, **kwargs):  # noqa: E501
        """offices_office_id_headlines_get  # noqa: E501

        Returns a list of news headlines for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_headlines_get_with_http_info(office_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'office_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method offices_office_id_headlines_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'office_id' is set
        if self.api_client.client_side_validation and ('office_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['office_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `office_id` when calling `offices_office_id_headlines_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in local_var_params:
            path_params['officeId'] = local_var_params['office_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}/headlines', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def offices_office_id_headlines_headline_id_get(self, office_id, headline_id, **kwargs):  # noqa: E501
        """offices_office_id_headlines_headline_id_get  # noqa: E501

        Returns a specific news headline for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_headlines_headline_id_get(office_id, headline_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param headline_id: (required)
        :type headline_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.offices_office_id_headlines_headline_id_get_with_http_info(office_id, headline_id, **kwargs)  # noqa: E501

    def offices_office_id_headlines_headline_id_get_with_http_info(self, office_id, headline_id, **kwargs):  # noqa: E501
        """offices_office_id_headlines_headline_id_get  # noqa: E501

        Returns a specific news headline for a given NWS office  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.offices_office_id_headlines_headline_id_get_with_http_info(office_id, headline_id, async_req=True)
        >>> result = thread.get()

        :param office_id: (required)
        :type office_id: str
        :param headline_id: (required)
        :type headline_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'office_id',
            'headline_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method offices_office_id_headlines_headline_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'office_id' is set
        if self.api_client.client_side_validation and ('office_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['office_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `office_id` when calling `offices_office_id_headlines_headline_id_get`")  # noqa: E501
        # verify the required parameter 'headline_id' is set
        if self.api_client.client_side_validation and ('headline_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['headline_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `headline_id` when calling `offices_office_id_headlines_headline_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'office_id' in local_var_params:
            path_params['officeId'] = local_var_params['office_id']  # noqa: E501
        if 'headline_id' in local_var_params:
            path_params['headlineId'] = local_var_params['headline_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/offices/{officeId}/headlines/{headlineId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def points_point_forecast_get(self, point, **kwargs):  # noqa: E501
        """points_point_forecast_get  # noqa: E501

        Returns a textual forecast for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_forecast_get(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.points_point_forecast_get_with_http_info(point, **kwargs)  # noqa: E501

    def points_point_forecast_get_with_http_info(self, point, **kwargs):  # noqa: E501
        """points_point_forecast_get  # noqa: E501

        Returns a textual forecast for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_forecast_get_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'point'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method points_point_forecast_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'point' is set
        if self.api_client.client_side_validation and ('point' not in local_var_params or  # noqa: E501
                                                        local_var_params['point'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `point` when calling `points_point_forecast_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in local_var_params:
            path_params['point'] = local_var_params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def points_point_forecast_hourly_get(self, point, **kwargs):  # noqa: E501
        """points_point_forecast_hourly_get  # noqa: E501

        Returns a textual hourly forecast for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_forecast_hourly_get(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.points_point_forecast_hourly_get_with_http_info(point, **kwargs)  # noqa: E501

    def points_point_forecast_hourly_get_with_http_info(self, point, **kwargs):  # noqa: E501
        """points_point_forecast_hourly_get  # noqa: E501

        Returns a textual hourly forecast for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_forecast_hourly_get_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'point'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method points_point_forecast_hourly_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'point' is set
        if self.api_client.client_side_validation and ('point' not in local_var_params or  # noqa: E501
                                                        local_var_params['point'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `point` when calling `points_point_forecast_hourly_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in local_var_params:
            path_params['point'] = local_var_params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.dwml+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}/forecast/hourly', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def points_point_get(self, point, **kwargs):  # noqa: E501
        """points_point_get  # noqa: E501

        Returns metadata about a given latitude/longitude point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_get(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.points_point_get_with_http_info(point, **kwargs)  # noqa: E501

    def points_point_get_with_http_info(self, point, **kwargs):  # noqa: E501
        """points_point_get  # noqa: E501

        Returns metadata about a given latitude/longitude point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_get_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'point'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method points_point_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'point' is set
        if self.api_client.client_side_validation and ('point' not in local_var_params or  # noqa: E501
                                                        local_var_params['point'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `point` when calling `points_point_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in local_var_params:
            path_params['point'] = local_var_params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def points_point_stations_get(self, point, **kwargs):  # noqa: E501
        """points_point_stations_get  # noqa: E501

        Returns a list of observation stations for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_stations_get(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.points_point_stations_get_with_http_info(point, **kwargs)  # noqa: E501

    def points_point_stations_get_with_http_info(self, point, **kwargs):  # noqa: E501
        """points_point_stations_get  # noqa: E501

        Returns a list of observation stations for a given point  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.points_point_stations_get_with_http_info(point, async_req=True)
        >>> result = thread.get()

        :param point: (required)
        :type point: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'point'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method points_point_stations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'point' is set
        if self.api_client.client_side_validation and ('point' not in local_var_params or  # noqa: E501
                                                        local_var_params['point'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `point` when calling `points_point_stations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'point' in local_var_params:
            path_params['point'] = local_var_params['point']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/points/{point}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_get(self, **kwargs):  # noqa: E501
        """products_get  # noqa: E501

        Returns a list of text products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_get(async_req=True)
        >>> result = thread.get()

        :param location: Location id
        :type location: list[str]
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param office: Issuing office
        :type office: list[str]
        :param wmoid: WMO id code
        :type wmoid: list[str]
        :param type: Product code
        :type type: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_get_with_http_info(**kwargs)  # noqa: E501

    def products_get_with_http_info(self, **kwargs):  # noqa: E501
        """products_get  # noqa: E501

        Returns a list of text products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param location: Location id
        :type location: list[str]
        :param start: Start time
        :type start: datetime
        :param end: End time
        :type end: datetime
        :param office: Issuing office
        :type office: list[str]
        :param wmoid: WMO id code
        :type wmoid: list[str]
        :param type: Product code
        :type type: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'location',
            'start',
            'end',
            'office',
            'wmoid',
            'type',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `products_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `products_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'location' in local_var_params and local_var_params['location'] is not None:  # noqa: E501
            query_params.append(('location', local_var_params['location']))  # noqa: E501
            collection_formats['location'] = 'csv'  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'office' in local_var_params and local_var_params['office'] is not None:  # noqa: E501
            query_params.append(('office', local_var_params['office']))  # noqa: E501
            collection_formats['office'] = 'csv'  # noqa: E501
        if 'wmoid' in local_var_params and local_var_params['wmoid'] is not None:  # noqa: E501
            query_params.append(('wmoid', local_var_params['wmoid']))  # noqa: E501
            collection_formats['wmoid'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_locations_get(self, **kwargs):  # noqa: E501
        """products_locations_get  # noqa: E501

        Returns a list of valid text product issuance locations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_locations_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_locations_get_with_http_info(**kwargs)  # noqa: E501

    def products_locations_get_with_http_info(self, **kwargs):  # noqa: E501
        """products_locations_get  # noqa: E501

        Returns a list of valid text product issuance locations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_locations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_locations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_locations_location_id_types_get(self, location_id, **kwargs):  # noqa: E501
        """products_locations_location_id_types_get  # noqa: E501

        Returns a list of valid text product types for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_locations_location_id_types_get(location_id, async_req=True)
        >>> result = thread.get()

        :param location_id: (required)
        :type location_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_locations_location_id_types_get_with_http_info(location_id, **kwargs)  # noqa: E501

    def products_locations_location_id_types_get_with_http_info(self, location_id, **kwargs):  # noqa: E501
        """products_locations_location_id_types_get  # noqa: E501

        Returns a list of valid text product types for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_locations_location_id_types_get_with_http_info(location_id, async_req=True)
        >>> result = thread.get()

        :param location_id: (required)
        :type location_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'location_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_locations_location_id_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'location_id' is set
        if self.api_client.client_side_validation and ('location_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['location_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `location_id` when calling `products_locations_location_id_types_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'location_id' in local_var_params:
            path_params['locationId'] = local_var_params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/locations/{locationId}/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_product_id_get(self, product_id, **kwargs):  # noqa: E501
        """products_product_id_get  # noqa: E501

        Returns a specific text product  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_product_id_get(product_id, async_req=True)
        >>> result = thread.get()

        :param product_id: (required)
        :type product_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_product_id_get_with_http_info(product_id, **kwargs)  # noqa: E501

    def products_product_id_get_with_http_info(self, product_id, **kwargs):  # noqa: E501
        """products_product_id_get  # noqa: E501

        Returns a specific text product  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_product_id_get_with_http_info(product_id, async_req=True)
        >>> result = thread.get()

        :param product_id: (required)
        :type product_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_product_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `products_product_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/{productId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_types_get(self, **kwargs):  # noqa: E501
        """products_types_get  # noqa: E501

        Returns a list of valid text product types and codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_types_get_with_http_info(**kwargs)  # noqa: E501

    def products_types_get_with_http_info(self, **kwargs):  # noqa: E501
        """products_types_get  # noqa: E501

        Returns a list of valid text product types and codes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_types_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_types_type_id_get(self, type_id, **kwargs):  # noqa: E501
        """products_types_type_id_get  # noqa: E501

        Returns a list of text products of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_get(type_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_types_type_id_get_with_http_info(type_id, **kwargs)  # noqa: E501

    def products_types_type_id_get_with_http_info(self, type_id, **kwargs):  # noqa: E501
        """products_types_type_id_get  # noqa: E501

        Returns a list of text products of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_get_with_http_info(type_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_types_type_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type_id' is set
        if self.api_client.client_side_validation and ('type_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['type_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type_id` when calling `products_types_type_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in local_var_params:
            path_params['typeId'] = local_var_params['type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_types_type_id_locations_get(self, type_id, **kwargs):  # noqa: E501
        """products_types_type_id_locations_get  # noqa: E501

        Returns a list of valid text product issuance locations for a given product type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_locations_get(type_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_types_type_id_locations_get_with_http_info(type_id, **kwargs)  # noqa: E501

    def products_types_type_id_locations_get_with_http_info(self, type_id, **kwargs):  # noqa: E501
        """products_types_type_id_locations_get  # noqa: E501

        Returns a list of valid text product issuance locations for a given product type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_locations_get_with_http_info(type_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_types_type_id_locations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type_id' is set
        if self.api_client.client_side_validation and ('type_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['type_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type_id` when calling `products_types_type_id_locations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in local_var_params:
            path_params['typeId'] = local_var_params['type_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def products_types_type_id_locations_location_id_get(self, type_id, location_id, **kwargs):  # noqa: E501
        """products_types_type_id_locations_location_id_get  # noqa: E501

        Returns a list of text products of a given type for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_locations_location_id_get(type_id, location_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param location_id: (required)
        :type location_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.products_types_type_id_locations_location_id_get_with_http_info(type_id, location_id, **kwargs)  # noqa: E501

    def products_types_type_id_locations_location_id_get_with_http_info(self, type_id, location_id, **kwargs):  # noqa: E501
        """products_types_type_id_locations_location_id_get  # noqa: E501

        Returns a list of text products of a given type for a given issuance location  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.products_types_type_id_locations_location_id_get_with_http_info(type_id, location_id, async_req=True)
        >>> result = thread.get()

        :param type_id: (required)
        :type type_id: str
        :param location_id: (required)
        :type location_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type_id',
            'location_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method products_types_type_id_locations_location_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type_id' is set
        if self.api_client.client_side_validation and ('type_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['type_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type_id` when calling `products_types_type_id_locations_location_id_get`")  # noqa: E501
        # verify the required parameter 'location_id' is set
        if self.api_client.client_side_validation and ('location_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['location_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `location_id` when calling `products_types_type_id_locations_location_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type_id' in local_var_params:
            path_params['typeId'] = local_var_params['type_id']  # noqa: E501
        if 'location_id' in local_var_params:
            path_params['locationId'] = local_var_params['location_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/products/types/{typeId}/locations/{locationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_profilers_station_id_get(self, station_id, **kwargs):  # noqa: E501
        """radar_profilers_station_id_get  # noqa: E501

        Returns metadata about a given radar wind profiler  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_profilers_station_id_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param time: Time interval
        :type time: str
        :param interval: Averaging interval
        :type interval: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_profilers_station_id_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def radar_profilers_station_id_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_profilers_station_id_get  # noqa: E501

        Returns metadata about a given radar wind profiler  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_profilers_station_id_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param time: Time interval
        :type time: str
        :param interval: Averaging interval
        :type interval: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'time',
            'interval'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_profilers_station_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `radar_profilers_station_id_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'time' in local_var_params and not re.search(r'((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))', local_var_params['time']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `time` when calling `radar_profilers_station_id_get`, must conform to the pattern `/((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))/`")  # noqa: E501
        if self.api_client.client_side_validation and 'interval' in local_var_params and not re.search(r'P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?', local_var_params['interval']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `interval` when calling `radar_profilers_station_id_get`, must conform to the pattern `/P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []
        if 'time' in local_var_params and local_var_params['time'] is not None:  # noqa: E501
            query_params.append(('time', local_var_params['time']))  # noqa: E501
        if 'interval' in local_var_params and local_var_params['interval'] is not None:  # noqa: E501
            query_params.append(('interval', local_var_params['interval']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/profilers/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_queues_host_get(self, host, **kwargs):  # noqa: E501
        """radar_queues_host_get  # noqa: E501

        Returns metadata about a given radar queue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_queues_host_get(host, async_req=True)
        >>> result = thread.get()

        :param host: (required)
        :type host: str
        :param limit: Record limit
        :type limit: int
        :param arrived: Range for arrival time
        :type arrived: str
        :param created: Range for creation time
        :type created: str
        :param published: Range for publish time
        :type published: str
        :param station: Station identifier
        :type station: str
        :param type: Record type
        :type type: str
        :param feed: Originating product feed
        :type feed: str
        :param resolution: Resolution version
        :type resolution: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_queues_host_get_with_http_info(host, **kwargs)  # noqa: E501

    def radar_queues_host_get_with_http_info(self, host, **kwargs):  # noqa: E501
        """radar_queues_host_get  # noqa: E501

        Returns metadata about a given radar queue  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_queues_host_get_with_http_info(host, async_req=True)
        >>> result = thread.get()

        :param host: (required)
        :type host: str
        :param limit: Record limit
        :type limit: int
        :param arrived: Range for arrival time
        :type arrived: str
        :param created: Range for creation time
        :type created: str
        :param published: Range for publish time
        :type published: str
        :param station: Station identifier
        :type station: str
        :param type: Record type
        :type type: str
        :param feed: Originating product feed
        :type feed: str
        :param resolution: Resolution version
        :type resolution: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'host',
            'limit',
            'arrived',
            'created',
            'published',
            'station',
            'type',
            'feed',
            'resolution'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_queues_host_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'host' is set
        if self.api_client.client_side_validation and ('host' not in local_var_params or  # noqa: E501
                                                        local_var_params['host'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `host` when calling `radar_queues_host_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `radar_queues_host_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `radar_queues_host_get`, must be a value greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'arrived' in local_var_params and not re.search(r'((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))', local_var_params['arrived']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `arrived` when calling `radar_queues_host_get`, must conform to the pattern `/((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))/`")  # noqa: E501
        if self.api_client.client_side_validation and 'created' in local_var_params and not re.search(r'((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))', local_var_params['created']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `created` when calling `radar_queues_host_get`, must conform to the pattern `/((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))/`")  # noqa: E501
        if self.api_client.client_side_validation and 'published' in local_var_params and not re.search(r'((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))', local_var_params['published']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `published` when calling `radar_queues_host_get`, must conform to the pattern `/((\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww])\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]|P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?)|((P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?)?\/(\d{4}-\d{2}-\d{2}[Tt]\d{2}:\d{2}:\d{2}([Zz]|[+-]\d{2}:?\d{2}?)|[Nn][Oo][Ww]))/`")  # noqa: E501
        if self.api_client.client_side_validation and 'resolution' in local_var_params and local_var_params['resolution'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `resolution` when calling `radar_queues_host_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'host' in local_var_params:
            path_params['host'] = local_var_params['host']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'arrived' in local_var_params and local_var_params['arrived'] is not None:  # noqa: E501
            query_params.append(('arrived', local_var_params['arrived']))  # noqa: E501
        if 'created' in local_var_params and local_var_params['created'] is not None:  # noqa: E501
            query_params.append(('created', local_var_params['created']))  # noqa: E501
        if 'published' in local_var_params and local_var_params['published'] is not None:  # noqa: E501
            query_params.append(('published', local_var_params['published']))  # noqa: E501
        if 'station' in local_var_params and local_var_params['station'] is not None:  # noqa: E501
            query_params.append(('station', local_var_params['station']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'feed' in local_var_params and local_var_params['feed'] is not None:  # noqa: E501
            query_params.append(('feed', local_var_params['feed']))  # noqa: E501
        if 'resolution' in local_var_params and local_var_params['resolution'] is not None:  # noqa: E501
            query_params.append(('resolution', local_var_params['resolution']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/queues/{host}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_servers_get(self, **kwargs):  # noqa: E501
        """radar_servers_get  # noqa: E501

        Returns a list of radar servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_servers_get(async_req=True)
        >>> result = thread.get()

        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_servers_get_with_http_info(**kwargs)  # noqa: E501

    def radar_servers_get_with_http_info(self, **kwargs):  # noqa: E501
        """radar_servers_get  # noqa: E501

        Returns a list of radar servers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_servers_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'reporting_host'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_servers_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'reporting_host' in local_var_params and local_var_params['reporting_host'] is not None:  # noqa: E501
            query_params.append(('reportingHost', local_var_params['reporting_host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/servers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_servers_id_get(self, id, **kwargs):  # noqa: E501
        """radar_servers_id_get  # noqa: E501

        Returns metadata about a given radar server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_servers_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_servers_id_get_with_http_info(id, **kwargs)  # noqa: E501

    def radar_servers_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """radar_servers_id_get  # noqa: E501

        Returns metadata about a given radar server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_servers_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param reporting_host: Show records from specific reporting host
        :type reporting_host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'reporting_host'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_servers_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `radar_servers_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'reporting_host' in local_var_params and local_var_params['reporting_host'] is not None:  # noqa: E501
            query_params.append(('reportingHost', local_var_params['reporting_host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/servers/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_stations_get(self, **kwargs):  # noqa: E501
        """radar_stations_get  # noqa: E501

        Returns a list of radar stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_get(async_req=True)
        >>> result = thread.get()

        :param station_type: Limit results to a specific station type or types
        :type station_type: list[str]
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_stations_get_with_http_info(**kwargs)  # noqa: E501

    def radar_stations_get_with_http_info(self, **kwargs):  # noqa: E501
        """radar_stations_get  # noqa: E501

        Returns a list of radar stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param station_type: Limit results to a specific station type or types
        :type station_type: list[str]
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_type',
            'reporting_host',
            'host'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_stations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'station_type' in local_var_params and local_var_params['station_type'] is not None:  # noqa: E501
            query_params.append(('stationType', local_var_params['station_type']))  # noqa: E501
            collection_formats['stationType'] = 'csv'  # noqa: E501
        if 'reporting_host' in local_var_params and local_var_params['reporting_host'] is not None:  # noqa: E501
            query_params.append(('reportingHost', local_var_params['reporting_host']))  # noqa: E501
        if 'host' in local_var_params and local_var_params['host'] is not None:  # noqa: E501
            query_params.append(('host', local_var_params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_stations_station_id_alarms_get(self, station_id, **kwargs):  # noqa: E501
        """radar_stations_station_id_alarms_get  # noqa: E501

        Returns metadata about a given radar station alarms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_station_id_alarms_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_stations_station_id_alarms_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def radar_stations_station_id_alarms_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_stations_station_id_alarms_get  # noqa: E501

        Returns metadata about a given radar station alarms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_station_id_alarms_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_stations_station_id_alarms_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `radar_stations_station_id_alarms_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations/{stationId}/alarms', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def radar_stations_station_id_get(self, station_id, **kwargs):  # noqa: E501
        """radar_stations_station_id_get  # noqa: E501

        Returns metadata about a given radar station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_station_id_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.radar_stations_station_id_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def radar_stations_station_id_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """radar_stations_station_id_get  # noqa: E501

        Returns metadata about a given radar station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.radar_stations_station_id_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param reporting_host: Show RDA and latency info from specific reporting host
        :type reporting_host: str
        :param host: Show latency info from specific LDM host
        :type host: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'reporting_host',
            'host'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method radar_stations_station_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `radar_stations_station_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []
        if 'reporting_host' in local_var_params and local_var_params['reporting_host'] is not None:  # noqa: E501
            query_params.append(('reportingHost', local_var_params['reporting_host']))  # noqa: E501
        if 'host' in local_var_params and local_var_params['host'] is not None:  # noqa: E501
            query_params.append(('host', local_var_params['host']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/radar/stations/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_get(self, **kwargs):  # noqa: E501
        """stations_get  # noqa: E501

        Returns a list of observation stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_get(async_req=True)
        >>> result = thread.get()

        :param id: State abbreviation
        :type id: list[str]
        :param state: State/marine area code
        :type state: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_get_with_http_info(**kwargs)  # noqa: E501

    def stations_get_with_http_info(self, **kwargs):  # noqa: E501
        """stations_get  # noqa: E501

        Returns a list of observation stations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param id: State abbreviation
        :type id: list[str]
        :param state: State/marine area code
        :type state: list[str]
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'state',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `stations_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `stations_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'state' in local_var_params and local_var_params['state'] is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
            collection_formats['state'] = 'csv'  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_station_id_get(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_get  # noqa: E501

        Returns metadata about a given observation station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_station_id_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def stations_station_id_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_get  # noqa: E501

        Returns metadata about a given observation station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_station_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `stations_station_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_station_id_observations_current_get(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_current_get  # noqa: E501

        Returns the latest observation for a station (use '/latest' instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_current_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param require_qc: Require QC
        :type require_qc: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_station_id_observations_current_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def stations_station_id_observations_current_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_current_get  # noqa: E501

        Returns the latest observation for a station (use '/latest' instead)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_current_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param require_qc: Require QC
        :type require_qc: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'require_qc'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_station_id_observations_current_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `stations_station_id_observations_current_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []
        if 'require_qc' in local_var_params and local_var_params['require_qc'] is not None:  # noqa: E501
            query_params.append(('require_qc', local_var_params['require_qc']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.obs+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations/current', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_station_id_observations_get(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_get  # noqa: E501

        Returns a list of observations for a given station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param station: Station ID
        :type station: list[str]
        :param start: Start date/time
        :type start: datetime
        :param end: End date/time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_station_id_observations_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def stations_station_id_observations_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_get  # noqa: E501

        Returns a list of observations for a given station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param station: Station ID
        :type station: list[str]
        :param start: Start date/time
        :type start: datetime
        :param end: End date/time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'station',
            'start',
            'end',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_station_id_observations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `stations_station_id_observations_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `stations_station_id_observations_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `stations_station_id_observations_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []
        if 'station' in local_var_params and local_var_params['station'] is not None:  # noqa: E501
            query_params.append(('station', local_var_params['station']))  # noqa: E501
            collection_formats['station'] = 'csv'  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_station_id_observations_latest_get(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_latest_get  # noqa: E501

        Returns the latest observation for a station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_latest_get(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param require_qc: Require QC
        :type require_qc: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_station_id_observations_latest_get_with_http_info(station_id, **kwargs)  # noqa: E501

    def stations_station_id_observations_latest_get_with_http_info(self, station_id, **kwargs):  # noqa: E501
        """stations_station_id_observations_latest_get  # noqa: E501

        Returns the latest observation for a station  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_latest_get_with_http_info(station_id, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param require_qc: Require QC
        :type require_qc: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'require_qc'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_station_id_observations_latest_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `stations_station_id_observations_latest_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501

        query_params = []
        if 'require_qc' in local_var_params and local_var_params['require_qc'] is not None:  # noqa: E501
            query_params.append(('require_qc', local_var_params['require_qc']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/vnd.noaa.obs+xml', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def stations_station_id_observations_time_get(self, station_id, time, **kwargs):  # noqa: E501
        """stations_station_id_observations_time_get  # noqa: E501

        Returns a single observation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_time_get(station_id, time, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param time: (required)
        :type time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.stations_station_id_observations_time_get_with_http_info(station_id, time, **kwargs)  # noqa: E501

    def stations_station_id_observations_time_get_with_http_info(self, station_id, time, **kwargs):  # noqa: E501
        """stations_station_id_observations_time_get  # noqa: E501

        Returns a single observation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stations_station_id_observations_time_get_with_http_info(station_id, time, async_req=True)
        >>> result = thread.get()

        :param station_id: (required)
        :type station_id: str
        :param time: (required)
        :type time: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'station_id',
            'time'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stations_station_id_observations_time_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'station_id' is set
        if self.api_client.client_side_validation and ('station_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['station_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `station_id` when calling `stations_station_id_observations_time_get`")  # noqa: E501
        # verify the required parameter 'time' is set
        if self.api_client.client_side_validation and ('time' not in local_var_params or  # noqa: E501
                                                        local_var_params['time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `time` when calling `stations_station_id_observations_time_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'station_id' in local_var_params:
            path_params['stationId'] = local_var_params['station_id']  # noqa: E501
        if 'time' in local_var_params:
            path_params['time'] = local_var_params['time']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/stations/{stationId}/observations/{time}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def thumbnails_satellite_area_get(self, area, **kwargs):  # noqa: E501
        """thumbnails_satellite_area_get  # noqa: E501

        Returns a thumbnail image for a satellite region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.thumbnails_satellite_area_get(area, async_req=True)
        >>> result = thread.get()

        :param area: (required)
        :type area: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.thumbnails_satellite_area_get_with_http_info(area, **kwargs)  # noqa: E501

    def thumbnails_satellite_area_get_with_http_info(self, area, **kwargs):  # noqa: E501
        """thumbnails_satellite_area_get  # noqa: E501

        Returns a thumbnail image for a satellite region  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.thumbnails_satellite_area_get_with_http_info(area, async_req=True)
        >>> result = thread.get()

        :param area: (required)
        :type area: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'area'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method thumbnails_satellite_area_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'area' is set
        if self.api_client.client_side_validation and ('area' not in local_var_params or  # noqa: E501
                                                        local_var_params['area'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `area` when calling `thumbnails_satellite_area_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'area' in local_var_params:
            path_params['area'] = local_var_params['area']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/jpeg', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/thumbnails/satellite/{area}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_forecast_zone_id_observations_get(self, zone_id, **kwargs):  # noqa: E501
        """zones_forecast_zone_id_observations_get  # noqa: E501

        Returns a list of observations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_forecast_zone_id_observations_get(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param start: Start date/time
        :type start: datetime
        :param end: End date/time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_forecast_zone_id_observations_get_with_http_info(zone_id, **kwargs)  # noqa: E501

    def zones_forecast_zone_id_observations_get_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """zones_forecast_zone_id_observations_get  # noqa: E501

        Returns a list of observations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_forecast_zone_id_observations_get_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param start: Start date/time
        :type start: datetime
        :param end: End date/time
        :type end: datetime
        :param limit: Limit
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'zone_id',
            'start',
            'end',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_forecast_zone_id_observations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'zone_id' is set
        if self.api_client.client_side_validation and ('zone_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['zone_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `zone_id` when calling `zones_forecast_zone_id_observations_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 500:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `zones_forecast_zone_id_observations_get`, must be a value less than or equal to `500`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `zones_forecast_zone_id_observations_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'zone_id' in local_var_params:
            path_params['zoneId'] = local_var_params['zone_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones/forecast/{zoneId}/observations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_forecast_zone_id_stations_get(self, zone_id, **kwargs):  # noqa: E501
        """zones_forecast_zone_id_stations_get  # noqa: E501

        Returns a list of observation stations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_forecast_zone_id_stations_get(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_forecast_zone_id_stations_get_with_http_info(zone_id, **kwargs)  # noqa: E501

    def zones_forecast_zone_id_stations_get_with_http_info(self, zone_id, **kwargs):  # noqa: E501
        """zones_forecast_zone_id_stations_get  # noqa: E501

        Returns a list of observation stations for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_forecast_zone_id_stations_get_with_http_info(zone_id, async_req=True)
        >>> result = thread.get()

        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'zone_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_forecast_zone_id_stations_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'zone_id' is set
        if self.api_client.client_side_validation and ('zone_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['zone_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `zone_id` when calling `zones_forecast_zone_id_stations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'zone_id' in local_var_params:
            path_params['zoneId'] = local_var_params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones/forecast/{zoneId}/stations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_get(self, **kwargs):  # noqa: E501
        """zones_get  # noqa: E501

        Returns a list of zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_get(async_req=True)
        >>> result = thread.get()

        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[str]
        :param region: Region code
        :type region: list[str]
        :param type: Zone type
        :type type: list[str]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_get_with_http_info(**kwargs)  # noqa: E501

    def zones_get_with_http_info(self, **kwargs):  # noqa: E501
        """zones_get  # noqa: E501

        Returns a list of zones  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[str]
        :param region: Region code
        :type region: list[str]
        :param type: Zone type
        :type type: list[str]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'id',
            'area',
            'region',
            'type',
            'point',
            'include_geometry',
            'limit',
            'effective'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `zones_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'area' in local_var_params and local_var_params['area'] is not None:  # noqa: E501
            query_params.append(('area', local_var_params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'point' in local_var_params and local_var_params['point'] is not None:  # noqa: E501
            query_params.append(('point', local_var_params['point']))  # noqa: E501
        if 'include_geometry' in local_var_params and local_var_params['include_geometry'] is not None:  # noqa: E501
            query_params.append(('include_geometry', local_var_params['include_geometry']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'effective' in local_var_params and local_var_params['effective'] is not None:  # noqa: E501
            query_params.append(('effective', local_var_params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_type_get(self, type, **kwargs):  # noqa: E501
        """zones_type_get  # noqa: E501

        Returns a list of zones of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_get(type, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[str]
        :param region: Region code
        :type region: list[str]
        :param type2: Zone type
        :type type2: list[str]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_type_get_with_http_info(type, **kwargs)  # noqa: E501

    def zones_type_get_with_http_info(self, type, **kwargs):  # noqa: E501
        """zones_type_get  # noqa: E501

        Returns a list of zones of a given type  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_get_with_http_info(type, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param id: Zone ID (forecast or county)
        :type id: list[str]
        :param area: State/marine area code
        :type area: list[str]
        :param region: Region code
        :type region: list[str]
        :param type2: Zone type
        :type type2: list[str]
        :param point: Point (latitude,longitude)
        :type point: str
        :param include_geometry: Include geometry in results (true/false)
        :type include_geometry: bool
        :param limit: Limit
        :type limit: int
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type',
            'id',
            'area',
            'region',
            'type2',
            'point',
            'include_geometry',
            'limit',
            'effective'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_type_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in local_var_params or  # noqa: E501
                                                        local_var_params['type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type` when calling `zones_type_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `zones_type_get`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'type' in local_var_params:
            path_params['type'] = local_var_params['type']  # noqa: E501

        query_params = []
        if 'id' in local_var_params and local_var_params['id'] is not None:  # noqa: E501
            query_params.append(('id', local_var_params['id']))  # noqa: E501
            collection_formats['id'] = 'csv'  # noqa: E501
        if 'area' in local_var_params and local_var_params['area'] is not None:  # noqa: E501
            query_params.append(('area', local_var_params['area']))  # noqa: E501
            collection_formats['area'] = 'csv'  # noqa: E501
        if 'region' in local_var_params and local_var_params['region'] is not None:  # noqa: E501
            query_params.append(('region', local_var_params['region']))  # noqa: E501
            collection_formats['region'] = 'csv'  # noqa: E501
        if 'type2' in local_var_params and local_var_params['type2'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type2']))  # noqa: E501
            collection_formats['type'] = 'csv'  # noqa: E501
        if 'point' in local_var_params and local_var_params['point'] is not None:  # noqa: E501
            query_params.append(('point', local_var_params['point']))  # noqa: E501
        if 'include_geometry' in local_var_params and local_var_params['include_geometry'] is not None:  # noqa: E501
            query_params.append(('include_geometry', local_var_params['include_geometry']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'effective' in local_var_params and local_var_params['effective'] is not None:  # noqa: E501
            query_params.append(('effective', local_var_params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_type_zone_id_forecast_get(self, type, zone_id, **kwargs):  # noqa: E501
        """zones_type_zone_id_forecast_get  # noqa: E501

        Returns the current zone forecast for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_zone_id_forecast_get(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_type_zone_id_forecast_get_with_http_info(type, zone_id, **kwargs)  # noqa: E501

    def zones_type_zone_id_forecast_get_with_http_info(self, type, zone_id, **kwargs):  # noqa: E501
        """zones_type_zone_id_forecast_get  # noqa: E501

        Returns the current zone forecast for a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_zone_id_forecast_get_with_http_info(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param zone_id: (required)
        :type zone_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type',
            'zone_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_type_zone_id_forecast_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in local_var_params or  # noqa: E501
                                                        local_var_params['type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type` when calling `zones_type_zone_id_forecast_get`")  # noqa: E501
        # verify the required parameter 'zone_id' is set
        if self.api_client.client_side_validation and ('zone_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['zone_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `zone_id` when calling `zones_type_zone_id_forecast_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in local_var_params:
            path_params['type'] = local_var_params['type']  # noqa: E501
        if 'zone_id' in local_var_params:
            path_params['zoneId'] = local_var_params['zone_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}/{zoneId}/forecast', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def zones_type_zone_id_get(self, type, zone_id, **kwargs):  # noqa: E501
        """zones_type_zone_id_get  # noqa: E501

        Returns metadata about a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_zone_id_get(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param zone_id: (required)
        :type zone_id: str
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.zones_type_zone_id_get_with_http_info(type, zone_id, **kwargs)  # noqa: E501

    def zones_type_zone_id_get_with_http_info(self, type, zone_id, **kwargs):  # noqa: E501
        """zones_type_zone_id_get  # noqa: E501

        Returns metadata about a given zone  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.zones_type_zone_id_get_with_http_info(type, zone_id, async_req=True)
        >>> result = thread.get()

        :param type: (required)
        :type type: str
        :param zone_id: (required)
        :type zone_id: str
        :param effective: Effective date/time
        :type effective: datetime
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'type',
            'zone_id',
            'effective'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zones_type_zone_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'type' is set
        if self.api_client.client_side_validation and ('type' not in local_var_params or  # noqa: E501
                                                        local_var_params['type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `type` when calling `zones_type_zone_id_get`")  # noqa: E501
        # verify the required parameter 'zone_id' is set
        if self.api_client.client_side_validation and ('zone_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['zone_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `zone_id` when calling `zones_type_zone_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in local_var_params:
            path_params['type'] = local_var_params['type']  # noqa: E501
        if 'zone_id' in local_var_params:
            path_params['zoneId'] = local_var_params['zone_id']  # noqa: E501

        query_params = []
        if 'effective' in local_var_params and local_var_params['effective'] is not None:  # noqa: E501
            query_params.append(('effective', local_var_params['effective']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/geo+json', 'application/ld+json', 'application/problem+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/zones/{type}/{zoneId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
